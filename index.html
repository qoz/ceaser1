<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Caesar Cipher Solver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Caesar Cipher Solver</h1>

  <!-- Play mode toggle -->
  <div class="section">
    <div class="label">Play mode:</div>
    <label class="label">
      <input type="radio" name="playMode" id="modePuzzle" value="puzzle" />
      Use puzzle list
    </label>
    <br />
    <label class="label">
      <input type="radio" name="playMode" id="modeManual" value="manual" />
      Enter puzzle manually
    </label>
  </div>

  <!-- Puzzle-based play (JSON puzzles + dev mode) -->
  <div id="puzzleModeSection">
    <div class="section">
      <div class="label">Load puzzles from file (JSON):</div>
      <input type="file" id="puzzleFileInput" accept=".json,application/json,text/plain" />

      <div class="label" style="margin-top:8px;">Choose a puzzle:</div>
      <select id="puzzleSelect">
        <option value="">(No puzzles loaded)</option>
      </select>

      <div id="hintInfo" class="label" style="margin-top:6px; text-align:center;"></div>
    </div>

    <div class="section">
      <label class="label">
        <input type="checkbox" id="devMode" />
        Developer mode: reveal puzzle solutions
      </label>
    </div>
  </div>

  <!-- Manual entry play -->
  <div id="manualModeSection">
    <div class="section">
      <div class="label">Enter encrypted message manually:</div>
      <textarea id="cipherInput" placeholder="Paste or type the encrypted text here..."></textarea>

      <div class="label" style="margin-top:8px;">
        (Optional) Enter known solution text for checking:
      </div>
      <input id="solutionInput" type="text"
             placeholder="If you know the plaintext, enter it here for 'Check Solution'..." />

      <button id="loadBtn" class="big-btn">Load Message</button>
    </div>
  </div>

  <!-- â­ Text display options -->
  <div class="section">
    <div class="label">Text display options:</div>
    <select id="fontSelect">
      <option value="default">Default</option>
      <option value="serif">Serif</option>
      <option value="sans">Sans-Serif</option>
      <option value="mono">Monospace</option>
      <option value="large">Large Print</option>
      <option value="spaced">Extra Letter Spacing</option>
    </select>
  </div>

  <!-- Encrypted text display -->
  <div class="section">
    <div class="label">Encrypted message:</div>
    <div id="cipher" class="cipher-text"></div>
  </div>

  <!-- Decoded output -->
  <div class="section">
    <div class="label">Your decryption:</div>
    <div id="plain" class="plain-text"></div>
  </div>

  <!-- Letter substitution UI -->
  <div class="section">
    <div class="label">Tap a letter to set its replacement:</div>
    <div id="mappings"></div>
  </div>

  <!-- Frequency view -->
  <div class="section">
    <div class="label">Frequency view (most common letters first):</div>
    <div id="freqView"></div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <button id="applyHintBtn" class="big-btn secondary">Apply Hint</button>
    <button id="checkBtn" class="big-btn">Check Solution</button>
    <button id="clearBtn" class="big-btn secondary">Clear Mappings</button>
  </div>

  <!-- Status display -->
  <div id="message"></div>

  <script>
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

    const cipherEl      = document.getElementById("cipher");
    const plainEl       = document.getElementById("plain");
    const mappingsEl    = document.getElementById("mappings");
    const messageEl     = document.getElementById("message");
    const checkBtn      = document.getElementById("checkBtn");
    const clearBtn      = document.getElementById("clearBtn");
    const loadBtn       = document.getElementById("loadBtn");
    const cipherInput   = document.getElementById("cipherInput");
    const solutionInput = document.getElementById("solutionInput");
    const freqViewEl    = document.getElementById("freqView");

    const puzzleFileInput = document.getElementById("puzzleFileInput");
    const puzzleSelect    = document.getElementById("puzzleSelect");
    const hintInfo        = document.getElementById("hintInfo");
    const applyHintBtn    = document.getElementById("applyHintBtn");
    const devModeCheckbox = document.getElementById("devMode");

    const modePuzzleRadio   = document.getElementById("modePuzzle");
    const modeManualRadio   = document.getElementById("modeManual");
    const puzzleModeSection = document.getElementById("puzzleModeSection");
    const manualModeSection = document.getElementById("manualModeSection");

    const fontSelect = document.getElementById("fontSelect");

    let cipherText   = "";
    let solutionText = "";
    let puzzles      = [];
    let currentHint  = null;
    let isPuzzleLoaded = false;

    // ---------------------------
    // FONT STYLE HANDLING
    // ---------------------------
    fontSelect.addEventListener("change", function () {
      const value = fontSelect.value;

      cipherEl.style.fontFamily = "";
      plainEl.style.fontFamily  = "";
      cipherEl.style.fontSize   = "";
      plainEl.style.fontSize    = "";
      cipherEl.style.letterSpacing = "";
      plainEl.style.letterSpacing  = "";

      if (value === "serif") {
        cipherEl.style.fontFamily = "serif";
        plainEl.style.fontFamily  = "serif";
      } else if (value === "sans") {
        cipherEl.style.fontFamily = "Arial, sans-serif";
        plainEl.style.fontFamily  = "Arial, sans-serif";
      } else if (value === "mono") {
        cipherEl.style.fontFamily = "monospace";
        plainEl.style.fontFamily  = "monospace";
      } else if (value === "large") {
        cipherEl.style.fontSize = "1.6em";
        plainEl.style.fontSize  = "1.6em";
      } else if (value === "spaced") {
        cipherEl.style.letterSpacing = "0.25em";
        plainEl.style.letterSpacing  = "0.25em";
      }
      // default = no changes (CSS controls appearance)
    });

    // ---------------------------
    // FREQUENCY + MAPPING LOGIC
    // ---------------------------

    function computeFrequencies() {
      const freq = {};
      alphabet.forEach(l => freq[l] = 0);
      for (const ch of cipherText.toUpperCase()) {
        if (alphabet.includes(ch)) freq[ch]++;
      }
      return freq;
    }

    function decodeText() {
      let decoded = "";
      for (const ch of cipherText) {
        const up = ch.toUpperCase();
        if (alphabet.includes(up)) {
          const rep = mapping[up];
          decoded += rep ? rep : "_&#8201;";
        } else {
          decoded += ch;
        }
      }
      plainEl.innerHTML = decoded;
    }

    function renderMappings() {
      mappingsEl.innerHTML = "";
      freqViewEl.innerHTML = "";

      if (!cipherText) return;

      const freq = computeFrequencies();
      const usedLetters = Object.keys(freq).filter(l => freq[l] > 0).sort();

      usedLetters.forEach(letter => {
        const btn = document.createElement("button");
        btn.className = "map-btn";
        btn.innerHTML =
          `<span class="letter">${letter}</span>
           <span class="count">${freq[letter]}</span>
           <span class="arrow">â†’</span>
           <span class="target">${mapping[letter] || "_"}</span>`;

        btn.addEventListener("click", function () {
          const current = mapping[letter] || "";
          const input = window.prompt(
            "Replace " + letter + " with (leave empty to clear):",
            current
          );
          if (input === null) return;

          const trimmed = input.trim().toUpperCase();

          // Clearing
          if (trimmed === "") {
            mapping[letter] = "";
            renderMappings();
            decodeText();
            messageEl.textContent = "";
            messageEl.className = "";
            return;
          }

          // SANITIZATION: exactly one Aâ€“Z letter
          if (!/^[A-Z]$/.test(trimmed)) {
            alert("Please enter exactly one letter (Aâ€“Z).");
            return;
          }

          const newChar = trimmed;

          // Check duplicate
          const conflict = alphabet.find(l =>
            mapping[l] === newChar && l !== letter
          );

          if (conflict) {
            const ok = window.confirm(
              "'" + newChar + "' is already used for '" +
              conflict + "'. Move it to '" + letter + "'?"
            );
            if (!ok) return;
            mapping[conflict] = "";
          }

          mapping[letter] = newChar;
          renderMappings();
          decodeText();
          messageEl.textContent = "";
          messageEl.className = "";
        });

        mappingsEl.appendChild(btn);
      });

      const sortedFreq = usedLetters.slice().sort((a, b) => freq[b] - freq[a]);
      sortedFreq.forEach(letter => {
        const div = document.createElement("div");
        div.className = "freq-item";
        div.innerHTML =
          `<span class="freq-letter">${letter}</span>
           <span class="freq-count">${freq[letter]}</span>`;
        freqViewEl.appendChild(div);
      });
    }

    function resetMappings() {
      alphabet.forEach(l => mapping[l] = "");
      renderMappings();
      decodeText();
    }

    function setHintInfo(hint) {
      currentHint = hint || null;
      hintInfo.textContent =
        (currentHint && currentHint.cipher && currentHint.plain)
        ? `Hint: ${currentHint.cipher} â†’ ${currentHint.plain} (use 'Apply Hint').`
        : "";
    }

    // ---------------------------
    // PUZZLE LOAD LOGIC
    // ---------------------------

    function loadPuzzleIntoGame(puzzle) {
      cipherText   = puzzle.cipher || "";
      solutionText = puzzle.solution || "";
      isPuzzleLoaded = true;

      cipherEl.textContent = cipherText;
      cipherInput.value    = cipherText;

      solutionInput.value = devModeCheckbox.checked
        ? solutionText
        : "";

      setHintInfo(puzzle.hint);

      if (!cipherText) {
        messageEl.textContent = "Selected puzzle has no cipher text.";
        messageEl.className = "err";
        return;
      }

      messageEl.textContent =
        (puzzle.publishDate ? "Publish date: " + puzzle.publishDate + ". " : "") +
        "Puzzle loaded. Start mapping letters or apply the hint.";
      messageEl.className = "";

      resetMappings();
    }

    function applyPuzzleData(data) {
      if (Array.isArray(data)) {
        puzzles = data;
      } else if (data && Array.isArray(data.puzzles)) {
        puzzles = data.puzzles;
      } else {
        puzzles = [];
      }

      puzzleSelect.innerHTML = "";

      if (!puzzles.length) {
        puzzleSelect.innerHTML = '<option value="">(No puzzles found)</option>';
        setHintInfo(null);
        return;
      }

      puzzleSelect.innerHTML = '<option value="">(Choose a puzzle)</option>';

      puzzles.forEach((p, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent =
          (p.title || ("Puzzle " + (i + 1))) +
          (p.publishDate ? " (" + p.publishDate + ")" : "");
        puzzleSelect.appendChild(opt);
      });

      setHintInfo(null);
    }

    puzzleFileInput.addEventListener("change", function (e) {
      const file = e.target.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function () {
        try {
          applyPuzzleData(JSON.parse(reader.result));
          messageEl.textContent = puzzles.length
            ? "Puzzles loaded from file. Choose one."
            : "No puzzles found.";
          messageEl.className = puzzles.length ? "" : "err";

        } catch {
          messageEl.textContent = "Invalid puzzles file (not JSON).";
          messageEl.className = "err";
        }
      };
      reader.readAsText(file);
    });

    puzzleSelect.addEventListener("change", function () {
      const idx = puzzleSelect.value;
      if (idx === "") {
        setHintInfo(null);
        isPuzzleLoaded = false;
        return;
      }
      loadPuzzleIntoGame(puzzles[Number(idx)]);
    });

    devModeCheckbox.addEventListener("change", function () {
      if (!isPuzzleLoaded || !cipherText) return;
      solutionInput.value =
        devModeCheckbox.checked ? solutionText : "";
    });

    applyHintBtn.addEventListener("click", function () {
      if (!cipherText) {
        messageEl.textContent = "Load a puzzle or message first.";
        messageEl.className = "err";
        return;
      }
      if (!currentHint || !currentHint.cipher || !currentHint.plain) {
        messageEl.textContent = "No hint for this puzzle.";
        messageEl.className = "err";
        return;
      }

      const C = currentHint.cipher.toUpperCase();
      const P = currentHint.plain.toUpperCase();

      if (!alphabet.includes(C) || !alphabet.includes(P)) {
        messageEl.textContent = "Invalid hint (Aâ€“Z only).";
        messageEl.className = "err";
        return;
      }

      const conflict = alphabet.find(l =>
        mapping[l] === P && l !== C
      );

      if (conflict) mapping[conflict] = "";
      mapping[C] = P;

      renderMappings();
      decodeText();
      messageEl.textContent = `Hint applied: ${C} â†’ ${P}.`;
      messageEl.className = "";
    });

    // ---------------------------
    // MANUAL LOAD
    // ---------------------------

    loadBtn.addEventListener("click", function () {
      cipherText   = cipherInput.value.trim();
      solutionText = solutionInput.value.trim();
      setHintInfo(null);
      isPuzzleLoaded = false;

      if (!cipherText) {
        messageEl.textContent = "Please enter an encrypted message.";
        messageEl.className = "err";
        cipherEl.textContent = "";
        plainEl.textContent = "";
        freqViewEl.innerHTML = "";
        mappingsEl.innerHTML = "";
        return;
      }

      cipherEl.textContent = cipherText;
      messageEl.textContent = solutionText
        ? "Message loaded. Start mapping letters or check solution."
        : "Message loaded. Start mapping letters.";
      messageEl.className = "";

      resetMappings();
    });

    // ---------------------------
    // CHECK SOLUTION
    // ---------------------------

    checkBtn.addEventListener("click", function () {
      if (!cipherText) {
        messageEl.textContent = "Load a message first.";
        messageEl.className = "err";
        return;
      }
      if (!solutionText) {
        messageEl.textContent = "No solution text available.";
        messageEl.className = "err";
        return;
      }

      const target = solutionText.replace(/\s+/g, "").toUpperCase();
      const guess = plainEl.textContent
        .replace(/_/g, "")
        .replace(/\s+/g, "")
        .toUpperCase();

      if (guess === target && guess.length > 0) {
        messageEl.textContent = "ðŸŽ‰ Correct! You solved the cipher.";
        messageEl.className = "ok";
      } else {
        messageEl.textContent = "Not quite yet.";
        messageEl.className = "err";
      }
    });

    clearBtn.addEventListener("click", function () {
      resetMappings();
      messageEl.textContent = "";
      messageEl.className = "";
    });


    // ---------------------------
    // MODE TOGGLE
    // ---------------------------

    function setMode(mode) {
      if (mode === "manual") {
        puzzleModeSection.style.display = "none";
        manualModeSection.style.display = "";
      } else {
        puzzleModeSection.style.display = "";
        manualModeSection.style.display = "none";
      }
    }

    modePuzzleRadio.addEventListener("change", () => {
      if (modePuzzleRadio.checked) setMode("puzzle");
    });

    modeManualRadio.addEventListener("change", () => {
      if (modeManualRadio.checked) setMode("manual");
    });

    // ---------------------------
    // AUTO-LOAD puzzles.json
    // ---------------------------

    function autoLoadPuzzlesFromServer() {
      if (typeof fetch !== "function") return;

      fetch("puzzles.json")
        .then(r => r.ok ? r.json() : Promise.reject())
        .then(data => {
          applyPuzzleData(data);
          if (puzzles.length) {
            messageEl.textContent = "Puzzles loaded from server. Choose one.";
            messageEl.className = "";
          }
        })
        .catch(() => {});
    }

    // Initial
    renderMappings();
    decodeText();
    autoLoadPuzzlesFromServer();

    modePuzzleRadio.checked = true;
    modeManualRadio.checked = false;
    setMode("puzzle");
  </script>
</body>
</html>
