<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Caesar Cipher Solver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Caesar Cipher Solver</h1>

  <!-- Puzzle selection -->
  <div class="section">
    <div class="label">Choose a puzzle:</div>
    <select id="puzzleSelect">
      <option value="">(No puzzles loaded)</option>
    </select>
    <div id="hintInfo" class="label" style="margin-top:6px; text-align:center;"></div>
  </div>

  <!-- Manual entry -->
  <div class="section">
    <div class="label">Or enter encrypted message manually:</div>
    <textarea id="cipherInput" placeholder="Paste or type the encrypted text here..."></textarea>

    <div class="label" style="margin-top:8px;">
      (Optional) Enter known solution text for checking:
    </div>
    <input id="solutionInput" type="text"
           placeholder="If you know the plaintext, enter it here for 'Check Solution'..." />

    <button id="loadBtn" class="big-btn">Load Message</button>
  </div>

  <!-- Letter box grid for cipher solving -->
  <div class="section">
    <div class="label">Encrypted message - Type your guesses in the boxes:</div>
    <div id="letterBoxGrid" class="letter-box-grid"></div>
  </div>

  <!-- Decoded output -->
  <div class="section">
    <div class="label">Your decryption:</div>
    <div id="plain" class="plain-text"></div>
  </div>

  <!-- Frequency view -->
  <div class="section">
    <div class="label">Frequency view (most common letters first):</div>
    <div id="freqView"></div>
  </div>

  <!-- Available letters -->
  <div class="section">
    <div class="label">Available letters for substitution:</div>
    <div id="availableLetters"></div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <button id="applyHintBtn" class="big-btn secondary">Apply Hint</button>
    <button id="checkBtn" class="big-btn">Check Solution</button>
    <button id="clearBtn" class="big-btn secondary">Clear Mappings</button>
  </div>

  <!-- Status display -->
  <div id="message"></div>

  <script>
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

    const letterBoxGridEl = document.getElementById("letterBoxGrid");
    const plainEl         = document.getElementById("plain");
    const messageEl       = document.getElementById("message");
    const checkBtn        = document.getElementById("checkBtn");
    const clearBtn        = document.getElementById("clearBtn");
    const loadBtn         = document.getElementById("loadBtn");
    const cipherInput     = document.getElementById("cipherInput");
    const solutionInput   = document.getElementById("solutionInput");
    const freqViewEl      = document.getElementById("freqView");
    const availableLettersEl = document.getElementById("availableLetters");
    const puzzleSelect    = document.getElementById("puzzleSelect");
    const hintInfo        = document.getElementById("hintInfo");
    const applyHintBtn    = document.getElementById("applyHintBtn");

    let cipherText   = "";
    let solutionText = "";
    let puzzles      = [];
    let currentHint  = null;

    // Mapping dictionary: cipher letter -> guessed plaintext letter
    const mapping = {};
    alphabet.forEach(function (l) { mapping[l] = ""; });

    function computeFrequencies() {
      const freq = {};
      alphabet.forEach(function (l) { freq[l] = 0; });
      for (const ch of cipherText.toUpperCase()) {
        if (alphabet.includes(ch)) {
          freq[ch] = freq[ch] + 1;
        }
      }
      return freq;
    }

    // Shows decoded text with underscores for unknown letters
    function decodeText() {
      let decoded = "";

      for (const ch of cipherText) {
        const up = ch.toUpperCase();
        if (alphabet.includes(up)) {
          const rep = mapping[up];
          if (rep) {
            decoded += rep;
          } else {
            decoded += "_";
          }
        } else {
          decoded += ch;
        }
      }

      plainEl.innerHTML = decoded;
    }

    // Render the letter box grid
    function renderLetterBoxGrid() {
      letterBoxGridEl.innerHTML = "";
      freqViewEl.innerHTML = "";

      if (!cipherText) {
        return;
      }

      const freq = computeFrequencies();

      // Split cipher text into words and create word containers
      const words = cipherText.split(/(\s+)/); // Keep delimiters (spaces)
      
      words.forEach(function(word) {
        if (!word) return;
        
        // If it's whitespace, create a space element
        if (/^\s+$/.test(word)) {
          const space = document.createElement("span");
          space.className = "word-space";
          space.textContent = " ";
          letterBoxGridEl.appendChild(space);
          return;
        }
        
        // Create a word container
        const wordContainer = document.createElement("span");
        wordContainer.className = "word-container";
        
        // Create letter boxes for each character in the word
        for (let i = 0; i < word.length; i++) {
          const ch = word[i];
          const up = ch.toUpperCase();
          const globalIndex = cipherText.indexOf(word) + i;

          if (alphabet.includes(up)) {
            // Create letter box container
            const box = document.createElement("span");
            box.className = "letter-box";

            // Input field for player's guess
            const input = document.createElement("input");
            input.type = "text";
            input.maxLength = 1;
            input.className = "letter-input";
            input.value = mapping[up] || "";
            input.dataset.cipherLetter = up;
            input.dataset.index = globalIndex;

            // Keydown event for backspace navigation
            input.addEventListener("keydown", function (e) {
              if (e.key === "Backspace" && !e.target.value) {
                e.preventDefault();
                moveToPreviousBox(parseInt(e.target.dataset.index));
              }
            });

            // Input event handler
            input.addEventListener("input", function (e) {
              let val = e.target.value.toUpperCase();
              
              // Filter non-letters
              if (val && !alphabet.includes(val)) {
                e.target.value = "";
                return;
              }

              const cipherLetter = e.target.dataset.cipherLetter;
              const oldValue = mapping[cipherLetter];

              if (!val) {
                // Clearing
                mapping[cipherLetter] = "";
                updateAllInputsForLetter(cipherLetter);
                decodeText();
                renderAvailableLetters();
                return;
              }

              // Check for duplicate assignments
              const conflict = alphabet.find(function (l) {
                return mapping[l] === val && l !== cipherLetter;
              });

              if (conflict) {
                // Auto-clear the conflicting mapping
                mapping[conflict] = "";
                updateAllInputsForLetter(conflict);
              }

              // Set new mapping
              mapping[cipherLetter] = val;
              e.target.value = val;
              
              // Update all inputs with same cipher letter
              updateAllInputsForLetter(cipherLetter);
              decodeText();
              renderAvailableLetters();
              
              // Auto-advance to next empty box
              advanceToNextEmptyBox(parseInt(e.target.dataset.index));
            });

            // Encrypted letter display
            const cipherLetterEl = document.createElement("div");
            cipherLetterEl.className = "cipher-letter";
            cipherLetterEl.textContent = ch;

            // Frequency count display
            const freqCountEl = document.createElement("div");
            freqCountEl.className = "freq-count-small";
            freqCountEl.textContent = freq[up];

            box.appendChild(input);
            box.appendChild(cipherLetterEl);
            box.appendChild(freqCountEl);

            wordContainer.appendChild(box);
          } else {
            // Non-letter character within word (punctuation)
            const punctBox = document.createElement("span");
            punctBox.className = "letter-box";
            
            // Punctuation at input level
            const punctTop = document.createElement("div");
            punctTop.className = "punctuation-top";
            punctTop.textContent = ch;
            
            // Punctuation at cipher letter level
            const punctuation = document.createElement("div");
            punctuation.className = "cipher-letter";
            punctuation.textContent = ch;
            
            // Empty spacer at frequency level
            const emptyFreq = document.createElement("div");
            emptyFreq.className = "freq-count-small";
            emptyFreq.innerHTML = "&nbsp;";
            
            punctBox.appendChild(punctTop);
            punctBox.appendChild(punctuation);
            punctBox.appendChild(emptyFreq);
            
            wordContainer.appendChild(punctBox);
          }
        }
        
        letterBoxGridEl.appendChild(wordContainer);
      });

      renderFrequencyView(freq);
    }

    // Update all input boxes for a specific cipher letter
    function updateAllInputsForLetter(cipherLetter) {
      const inputs = letterBoxGridEl.querySelectorAll('input[data-cipher-letter="' + cipherLetter + '"]');
      inputs.forEach(function (input) {
        input.value = mapping[cipherLetter] || "";
      });
    }

    // Auto-advance focus to next empty input box
    function advanceToNextEmptyBox(currentIndex) {
      const allInputs = letterBoxGridEl.querySelectorAll('.letter-input');
      
      // Find the current input element
      let foundCurrent = false;
      for (let i = 0; i < allInputs.length; i++) {
        const inputIndex = parseInt(allInputs[i].dataset.index);
        
        // Skip until we find an input after the current one
        if (inputIndex <= currentIndex) {
          continue;
        }
        
        // Focus on the first empty box after the current position
        if (!allInputs[i].value) {
          allInputs[i].focus();
          return;
        }
      }
    }

    // Move to previous input box on backspace
    function moveToPreviousBox(currentIndex) {
      const allInputs = letterBoxGridEl.querySelectorAll('.letter-input');
      
      // Find the previous input before the current position
      for (let i = allInputs.length - 1; i >= 0; i--) {
        const inputIndex = parseInt(allInputs[i].dataset.index);
        
        if (inputIndex < currentIndex) {
          allInputs[i].focus();
          return;
        }
      }
    }

    function renderFrequencyView(freq) {
      const usedLetters = Object.keys(freq).filter(function (l) {
        return freq[l] > 0;
      });

      // Frequency view (sorted by descending frequency)
      const sortedFreqLetters = usedLetters.slice().sort(function (a, b) {
        return freq[b] - freq[a];
      });

      sortedFreqLetters.forEach(function (letter) {
        const div = document.createElement("div");
        div.className = "freq-item";
        div.innerHTML =
          '<span class="freq-letter">' + letter + '</span>' +
          '<span class="freq-count">' + freq[letter] + '</span>';
        freqViewEl.appendChild(div);
      });
    }

    function renderAvailableLetters() {
      var usedLetters = [];
      alphabet.forEach(function (l) {
        if (mapping[l]) {
          usedLetters.push(mapping[l]);
        }
      });

      availableLettersEl.innerHTML = "";
      alphabet.forEach(function (letter) {
        var span = document.createElement("span");
        span.className = "alphabet-letter";
        if (!usedLetters.includes(letter)) {
          span.className += " available";
        }
        span.textContent = letter;
        availableLettersEl.appendChild(span);
      });
    }

    function resetMappings() {
      alphabet.forEach(function (l) { mapping[l] = ""; });
      renderLetterBoxGrid();
      decodeText();
      renderAvailableLetters();
    }

    function setHintInfo(hint) {
      currentHint = hint || null;
      if (currentHint && currentHint.cipher && currentHint.plain) {
        var c = String(currentHint.cipher).toUpperCase();
        var p = String(currentHint.plain).toUpperCase();
        hintInfo.textContent = "Hint: " + c + " â†’ " + p + " (use 'Apply Hint').";
        applyHintBtn.style.display = "";
      } else {
        hintInfo.textContent = "";
        applyHintBtn.style.display = "none";
      }
    }

    function loadPuzzleIntoGame(puzzle) {
      cipherText   = puzzle.cipher || "";
      solutionText = puzzle.solution || "";

      cipherInput.value    = cipherText;
      solutionInput.value  = "";

      setHintInfo(puzzle.hint);

      if (!cipherText) {
        messageEl.textContent = "Selected puzzle has no cipher text.";
        messageEl.className   = "err";
        return;
      }

      var dateText = puzzle.publishDate ? "Publish date: " + puzzle.publishDate + ". " : "";
      var hintText = (puzzle.hint && puzzle.hint.cipher && puzzle.hint.plain) ? " or apply the hint" : "";
      messageEl.textContent = dateText + "Puzzle loaded. Start typing your guesses" + hintText + ".";
      messageEl.className = "";

      resetMappings();
    }

    // Helper: apply puzzle data structure from JSON into UI
    function applyPuzzleData(data) {
      // Support either { puzzles: [...] } or [...] at top level
      if (Array.isArray(data)) {
        puzzles = data;
      } else if (data && Array.isArray(data.puzzles)) {
        puzzles = data.puzzles;
      } else {
        puzzles = [];
      }

      puzzleSelect.innerHTML = "";

      if (!puzzles.length) {
        puzzleSelect.innerHTML = '<option value="">(No puzzles found)</option>';
        setHintInfo(null);
        return;
      }

      puzzleSelect.innerHTML = '<option value="">(Choose a puzzle)</option>';
      puzzles.forEach(function (p, index) {
        const opt = document.createElement("option");
        const title = p.title || ("Puzzle " + (index + 1));
        const date  = p.publishDate ? (" (" + p.publishDate + ")") : "";
        opt.value = String(index);
        opt.textContent = title + date;
        puzzleSelect.appendChild(opt);
      });

      setHintInfo(null);
    }

    // Selecting a puzzle
    puzzleSelect.addEventListener("change", function () {
      const value = puzzleSelect.value;
      if (value === "") {
        setHintInfo(null);
        return;
      }
      const index = parseInt(value, 10);
      if (isNaN(index) || !puzzles[index]) {
        setHintInfo(null);
        return;
      }
      loadPuzzleIntoGame(puzzles[index]);
    });

    // Apply hint button
    applyHintBtn.addEventListener("click", function () {
      if (!cipherText) {
        messageEl.textContent = "Load a puzzle or message first.";
        messageEl.className = "err";
        return;
      }
      if (!currentHint || !currentHint.cipher || !currentHint.plain) {
        messageEl.textContent = "No hint available for this puzzle.";
        messageEl.className = "err";
        return;
      }

      var cipherLetter = String(currentHint.cipher).toUpperCase();
      var plainLetter  = String(currentHint.plain).toUpperCase();

      if (!alphabet.includes(cipherLetter) || !alphabet.includes(plainLetter)) {
        messageEl.textContent = "Hint is invalid (must be Aâ€“Z).";
        messageEl.className = "err";
        return;
      }

      // Resolve duplicates automatically (hint is trusted)
      const conflict = alphabet.find(function (l) {
        return mapping[l] === plainLetter && l !== cipherLetter;
      });
      if (conflict) {
        mapping[conflict] = "";
      }

      mapping[cipherLetter] = plainLetter;

      updateAllInputsForLetter(cipherLetter);
      if (conflict) {
        updateAllInputsForLetter(conflict);
      }
      decodeText();
      renderAvailableLetters();
      messageEl.textContent = "Hint applied: " + cipherLetter + " â†’ " + plainLetter + ".";
      messageEl.className = "";
    });

    // Manual load
    loadBtn.addEventListener("click", function () {
      cipherText   = (cipherInput.value || "").trim();
      solutionText = (solutionInput.value || "").trim();
      setHintInfo(null);

      if (!cipherText) {
        messageEl.textContent = "Please enter an encrypted message.";
        messageEl.className   = "err";
        letterBoxGridEl.innerHTML = "";
        plainEl.textContent   = "";
        freqViewEl.innerHTML  = "";
        return;
      }

      if (solutionText) {
        messageEl.textContent = "Message loaded. Start typing your guesses or tap 'Check Solution' when ready.";
      } else {
        messageEl.textContent = "Message loaded. Start typing your guesses.";
      }
      messageEl.className = "";

      resetMappings();
    });

    checkBtn.addEventListener("click", function () {
      if (!cipherText) {
        messageEl.textContent = "Load a message first.";
        messageEl.className = "err";
        return;
      }

      if (!solutionText) {
        messageEl.textContent = "No solution text provided.";
        messageEl.className = "err";
        return;
      }

      var target = solutionText.replace(/\s+/g, "").toUpperCase();
      var guess = plainEl.textContent
        .replace(/_/g, "")
        .replace(/\s+/g, "")
        .toUpperCase();

      if (guess === target && guess.length > 0) {
        messageEl.textContent = "ðŸŽ‰ Correct! You solved the cipher.";
        messageEl.className = "ok";
      } else {
        messageEl.textContent = "Not quite yet. Keep trying!";
        messageEl.className = "err";
      }
    });

    clearBtn.addEventListener("click", function () {
      resetMappings();
      messageEl.textContent = "";
      messageEl.className = "";
    });

    // Try to auto-load puzzles.json from the same site
    function autoLoadPuzzlesFromServer() {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', 'puzzles.json', true);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            try {
              var data = JSON.parse(xhr.responseText);
              applyPuzzleData(data);
              if (puzzles.length) {
                messageEl.textContent = "Puzzles loaded from server. Choose one from the dropdown.";
                messageEl.className = "";
              }
            } catch (err) {
              console.log("Error parsing puzzles.json:", err);
            }
          } else {
            console.log("Failed to load puzzles.json, status:", xhr.status);
          }
        }
      };
      xhr.send();
    }

    // Initial render
    renderLetterBoxGrid();
    decodeText();
    renderAvailableLetters();
    autoLoadPuzzlesFromServer();
  </script>
</body>
</html>
